{"ast":null,"code":"/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript\n *\n * @author Alex Sexton - @SlexAxton, Eemeli Aro\n * @version 0.3.1\n * @copyright 2012-2016 Alex Sexton, Eemeli Aro, and Contributors\n * @license To use or fork, MIT. To contribute back, Dojo CLA  */\n\n/** Utility function for quoting an Object's key value iff required\n *\n * @private  */\nfunction propname(key, obj) {\n  /* Quote the key if it contains invalid characters or is an\n   * ECMAScript 3rd Edition reserved word.\n   */\n  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key) && ['break', 'continue', 'delete', 'else', 'for', 'function', 'if', 'in', 'new', 'return', 'this', 'typeof', 'var', 'void', 'while', 'with', 'case', 'catch', 'default', 'do', 'finally', 'instanceof', 'switch', 'throw', 'try'].indexOf(key) < 0) {\n    return obj ? obj + '.' + key : key;\n  } else {\n    var jkey = JSON.stringify(key);\n    return obj ? obj + '[' + jkey + ']' : jkey;\n  }\n}\n/** Utility formatter function for enforcing Bidi Structured Text by using UCC\n *\n * @private  */\n\n\nfunction bidiMarkText(text, locale) {\n  function isLocaleRTL(locale) {\n    /* list inlined from data extracted from CLDR v27 & v28\n     * to verify/recreate, use the following:\n     *   git clone https://github.com/unicode-cldr/cldr-misc-full.git\n     *   cd cldr-misc-full/main/\n     *   grep characterOrder -r . | tr '\"/' '\\t' | cut -f2,6 | grep -C4 right-to-left\n     */\n    var rtlLanguages = ['ar', 'ckb', 'fa', 'he', 'ks($|[^bfh])', 'lrc', 'mzn', 'pa-Arab', 'ps', 'ug', 'ur', 'uz-Arab', 'yi'];\n    return new RegExp('^' + rtlLanguages.join('|^')).test(locale);\n  }\n\n  var mark = JSON.stringify(isLocaleRTL(locale) ? '\\u200F' : '\\u200E');\n  return mark + ' + ' + text + ' + ' + mark;\n}\n/** Create a new message formatter\n *\n * @class\n * @param {string|string[]} [locale=\"en\"] - The locale to use, with fallbacks\n * @param {function} [pluralFunc] - Optional custom pluralization function\n * @param {function[]} [formatters] - Optional custom formatting functions  */\n\n\nfunction MessageFormat(locale, pluralFunc, formatters) {\n  if (!locale) {\n    this.lc = ['en'];\n  } else if (typeof locale == 'string') {\n    this.lc = [];\n\n    for (var l = locale; l; l = l.replace(/[-_]?[^-_]*$/, '')) this.lc.push(l);\n  } else {\n    this.lc = locale;\n  }\n\n  if (!pluralFunc) {\n    if (this.lc.every(function (l) {\n      pluralFunc = MessageFormat.plurals[l];\n      return !pluralFunc;\n    })) {\n      throw new Error('Plural function for locale `' + this.lc.join(',') + '` not found');\n    }\n  }\n\n  this.runtime = new Runtime(this.lc[0], pluralFunc, formatters);\n}\n\nmodule.exports = MessageFormat;\n/** Parse an input string to its AST\n *\n *  Precompiled from `lib/messageformat-parser.pegjs` by\n *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object\n *  to enable testing.\n *\n * @private  */\n\nMessageFormat._parse = require('./messageformat-parser').parse;\n/** Pluralization functions from\n *  {@link http://github.com/eemeli/make-plural.js make-plural}\n *\n * @memberof MessageFormat\n * @type Object.<string,function>  */\n\nMessageFormat.plurals = require('make-plural/plurals');\n/** Default number formatting functions in the style of ICU's\n *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}\n *  implemented using the\n *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}\n *  object defined by ECMA-402.\n *\n *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so\n *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.\n *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these\n *  functions to be available for inclusion in the output.\n *\n * @see MessageFormat#setIntlSupport\n *\n * @namespace\n * @memberof MessageFormat\n * @property {function} number - Represent a number as an integer, percent or currency value\n * @property {function} date - Represent a date as a full/long/default/short string\n * @property {function} time - Represent a time as a full/long/default/short string\n *\n * @example\n * var mf = new MessageFormat('en').setIntlSupport(true);\n * mf.currency = 'EUR';\n * var cf = mf.compile('The total is {V,number,currency}.');\n *\n * cf({ V: 5.5 })\n * // 'The total is €5.50.'\n *\n * @example\n * var mf = new MessageFormat('en', null, {number: MessageFormat.number});\n * mf.currency = 'EUR';\n * var cf = mf.compile('The total is {V,number,currency}.');\n *\n * cf({ V: 5.5 })\n * // 'The total is €5.50.'  */\n\nMessageFormat.formatters = {\n  number: function (self) {\n    return new Function(\"v,lc,p\", \"return Intl.NumberFormat(lc,\\n\" + \"    p=='integer' ? {maximumFractionDigits:0}\\n\" + \"  : p=='percent' ? {style:'percent'}\\n\" + \"  : p=='currency' ? {style:'currency', currency:'\" + (self.currency || 'USD') + \"', minimumFractionDigits:2, maximumFractionDigits:2}\\n\" + \"  : {}).format(v)\");\n  },\n  date: function (v, lc, p) {\n    var o = {\n      day: 'numeric',\n      month: 'short',\n      year: 'numeric'\n    };\n\n    switch (p) {\n      case 'full':\n        o.weekday = 'long';\n\n      case 'long':\n        o.month = 'long';\n        break;\n\n      case 'short':\n        o.month = 'numeric';\n    }\n\n    return new Date(v).toLocaleDateString(lc, o);\n  },\n  time: function (v, lc, p) {\n    var o = {\n      second: 'numeric',\n      minute: 'numeric',\n      hour: 'numeric'\n    };\n\n    switch (p) {\n      case 'full':\n      case 'long':\n        o.timeZoneName = 'short';\n        break;\n\n      case 'short':\n        delete o.minute;\n    }\n\n    return new Date(v).toLocaleTimeString(lc, o);\n  }\n};\n/** Enable or disable the addition of Unicode control characters to all input\n *  to preserve the integrity of the output when mixing LTR and RTL text.\n *\n * @see http://cldr.unicode.org/development/development-process/design-proposals/bidi-handling-of-structured-text\n *\n * @memberof MessageFormat\n * @param {boolean} [enable=true]\n * @returns {MessageFormat} The MessageFormat instance, to allow for chaining\n *\n * @example\n * // upper case stands for RTL characters, output is shown as rendered\n * var mf = new MessageFormat('en');\n *\n * mf.compile('{0} >> {1} >> {2}')(['first', 'SECOND', 'THIRD']);\n * // 'first >> THIRD << SECOND'\n *\n * mf.setBiDiSupport(true);\n * mf.compile('{0} >> {1} >> {2}')(['first', 'SECOND', 'THIRD']);\n * // 'first >> SECOND >> THIRD'  */\n\nMessageFormat.prototype.setBiDiSupport = function (enable) {\n  this.bidiSupport = !!enable || typeof enable == 'undefined';\n  return this;\n};\n/** Enable or disable support for the default formatters, which require the\n *  `Intl` object. Note that this can't be autodetected, as the environment\n *  in which the formatted text is compiled into Javascript functions is not\n *  necessarily the same environment in which they will get executed.\n *\n * @see MessageFormat.formatters\n *\n * @memberof MessageFormat\n * @param {boolean} [enable=true]\n * @returns {MessageFormat} The MessageFormat instance, to allow for chaining\n *\n * @example\n * // Intl is not defined in default Node until 0.11.15 / 0.12.0\n * var Intl = require('intl');\n * var mf = new MessageFormat('en').setIntlSupport(true);\n * mf.currency = 'EUR';\n *\n * mf.compile('The total is {V,number,currency}.')({ V: 5.5 });\n * // 'The total is €5.50.'  */\n\n\nMessageFormat.prototype.setIntlSupport = function (enable) {\n  this.withIntlSupport = !!enable || typeof enable == 'undefined';\n  return this;\n};\n/** A set of utility functions that are called by the compiled Javascript\n *  functions, these are included locally in the output of {@link\n *  MessageFormat#compile compile()}.\n *\n * @class\n * @param {string} [locale] - The parsed locale\n * @param {function} [pluralFunc] - Pluralization function for the locale\n * @param {function[]} [formatters] - Optional custom formatting functions  */\n\n\nfunction Runtime(locale, pluralFunc, formatters) {\n  /** Pluralization functions included in compiled output\n   *\n   * @instance\n   * @type Object.<string,function>  */\n  this.pluralFuncs = {};\n  this.pluralFuncs[locale] = pluralFunc;\n  /** Custom formatting functions called by `{var, fn[, args]*}` syntax\n   *\n   *  For examples, see {@link MessageFormat.formatters}\n   *\n   * @instance\n   * @see MessageFormat.formatters\n   * @type Object.<string,function>  */\n\n  this.fmt = {};\n  if (formatters) for (var f in formatters) {\n    this.fmt[f] = formatters[f];\n  }\n}\n\nRuntime.prototype = {\n  /** Utility function for `#` in plural rules\n   *\n   * @param {number} value - The value to operate on\n   * @param {number} [offset=0] - An optional offset, set by the surrounding context  */\n  number: function (value, offset) {\n    if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n    return value - (offset || 0);\n  },\n\n  /** Utility function for `{N, plural|selectordinal, ...}`\n   *\n   * @param {number} value - The key to use to find a pluralization rule\n   * @param {number} offset - An offset to apply to `value`\n   * @param {function} lcfunc - A locale function from `pluralFuncs`\n   * @param {Object.<string,string>} data - The object from which results are looked up\n   * @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules\n   * @returns {string} The result of the pluralization  */\n  plural: function (value, offset, lcfunc, data, isOrdinal) {\n    if ({}.hasOwnProperty.call(data, value)) return data[value]();\n    if (offset) value -= offset;\n    var key = lcfunc(value, isOrdinal);\n    if (key in data) return data[key]();\n    return data.other();\n  },\n\n  /** Utility function for `{N, select, ...}`\n   *\n   * @param {number} value - The key to use to find a selection\n   * @param {Object.<string,string>} data - The object from which results are looked up\n   * @returns {string} The result of the select statement  */\n  select: function (value, data) {\n    if ({}.hasOwnProperty.call(data, value)) return data[value]();\n    return data.other();\n  },\n\n  /** Custom stringifier\n   *\n   * @example\n   * var mf = new MessageFormat('en');\n   * console.log(mf.runtime.toString())\n   * > var pluralFuncs = {\n   * >   en: function (n, ord) {\n   * >     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,\n   * >         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);\n   * >     if (ord) return (n10 == 1 && n100 != 11) ? 'one'\n   * >         : (n10 == 2 && n100 != 12) ? 'two'\n   * >         : (n10 == 3 && n100 != 13) ? 'few'\n   * >         : 'other';\n   * >     return (n == 1 && v0) ? 'one' : 'other';\n   * >   }\n   * > };\n   * > var fmt = {};\n   * > var number = function (value, offset) {\n   * >   if (isNaN(value)) throw new Error(\"'\" + value + \"' isn't a number.\");\n   * >   return value - (offset || 0);\n   * > };\n   * > var plural = function (value, offset, lcfunc, data, isOrdinal) {\n   * >   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n   * >   if (offset) value -= offset;\n   * >   var key = lcfunc(value, isOrdinal);\n   * >   if (key in data) return data[key]();\n   * >   return data.other();\n   * > };\n   * > var select = function (value, data) {\n   * >   if ({}.hasOwnProperty.call(data, value)) return data[value]();\n   * >   return data.other()\n   * > };  */\n  toString: function () {\n    var _stringify = function (o, level) {\n      if (typeof o != 'object') {\n        var funcStr = o.toString().replace(/^(function )\\w*/, '$1');\n        var indent = /([ \\t]*)\\S.*$/.exec(funcStr);\n        return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;\n      }\n\n      var s = [];\n\n      for (var i in o) if (i != 'toString') {\n        if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\\n');else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));\n      }\n\n      if (level == 0) return s.join('');\n      if (s.length == 0) return '{}';\n      var indent = '  ';\n\n      while (--level) indent += '  ';\n\n      return '{\\n' + s.join(',\\n').replace(/^/gm, indent) + '\\n}';\n    };\n\n    return _stringify(this, 0);\n  }\n};\n/** Recursively map an AST to its resulting string\n *\n * @memberof MessageFormat\n * @param ast - the Ast node for which the JS code should be generated\n * @private  */\n\nMessageFormat.prototype._precompile = function (ast, data) {\n  data = data || {\n    keys: {},\n    offset: {}\n  };\n  var r = [],\n      i,\n      tmp,\n      args = [];\n\n  switch (ast.type) {\n    case 'messageFormatPattern':\n      for (i = 0; i < ast.statements.length; ++i) {\n        r.push(this._precompile(ast.statements[i], data));\n      }\n\n      tmp = r.join(' + ') || '\"\"';\n      return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';\n\n    case 'messageFormatElement':\n      data.pf_count = data.pf_count || 0;\n\n      if (ast.output) {\n        var ret = propname(ast.argumentIndex, 'd');\n        return this.bidiSupport ? bidiMarkText(ret, this.lc) : ret;\n      } else {\n        data.keys[data.pf_count] = ast.argumentIndex;\n        return this._precompile(ast.elementFormat, data);\n      }\n\n      return '';\n\n    case 'elementFormat':\n      args = [propname(data.keys[data.pf_count], 'd')];\n\n      switch (ast.key) {\n        case 'select':\n          args.push(this._precompile(ast.val, data));\n          return 'select(' + args.join(', ') + ')';\n\n        case 'selectordinal':\n          args = args.concat([0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1]);\n          return 'plural(' + args.join(', ') + ')';\n\n        case 'plural':\n          data.offset[data.pf_count || 0] = ast.val.offset || 0;\n          args = args.concat([data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data)]);\n          return 'plural(' + args.join(', ') + ')';\n\n        default:\n          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && ast.key in MessageFormat.formatters) {\n            tmp = MessageFormat.formatters[ast.key];\n            this.runtime.fmt[ast.key] = typeof tmp(this) == 'function' ? tmp(this) : tmp;\n          }\n\n          args.push(JSON.stringify(this.lc));\n          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));\n          return 'fmt.' + ast.key + '(' + args.join(', ') + ')';\n      }\n\n    case 'pluralFormatPattern':\n    case 'selectFormatPattern':\n      data.pf_count = data.pf_count || 0;\n      if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;\n      var needOther = true;\n\n      for (i = 0; i < ast.pluralForms.length; ++i) {\n        var key = ast.pluralForms[i].key;\n        if (key === 'other') needOther = false;\n        var data_copy = JSON.parse(JSON.stringify(data));\n        data_copy.pf_count++;\n        r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');\n      }\n\n      if (needOther) throw new Error(\"No 'other' form found in \" + ast.type + \" \" + data.pf_count);\n      return '{ ' + r.join(', ') + ' }';\n\n    case 'string':\n      return JSON.stringify(ast.val || \"\");\n\n    case 'octothorpe':\n      if (!data.pf_count) return '\"#\"';\n      args = [propname(data.keys[data.pf_count - 1], 'd')];\n      if (data.offset[data.pf_count - 1]) args.push(data.offset[data.pf_count - 1]);\n      return 'number(' + args.join(', ') + ')';\n\n    default:\n      throw new Error('Bad AST type: ' + ast.type);\n  }\n};\n/** Compile messages into an executable function with clean string\n *  representation.\n *\n *  If `messages` is a single string including ICU MessageFormat declarations,\n *  `opt` is ignored and the returned function takes a single Object parameter\n *  `d` representing each of the input's defined variables. The returned\n *  function will be defined in a local scope that includes all the required\n *  runtime variables.\n *\n *  If `messages` is a map of keys to strings, or a map of namespace keys to\n *  such key/string maps, the returned function will fill the specified global\n *  with javascript functions matching the structure of the input. In such use,\n *  the result of `compile()` may be serialized using its `toString()` method,\n *  including all required runtime function definitions. If `opt.global` is\n *  null, calling the output function will return the object itself.\n *\n *  Together, the input parameters should match the following patterns:\n *  ```js\n *  messages = \"string\" || { key0: \"string0\", key1: \"string1\", ... } || {\n *    ns0: { key0: \"string0\", key1: \"string1\", ...  },\n *    ns1: { key0: \"string0\", key1: \"string1\", ...  },\n *    ...\n *  }\n *\n *  opt = null || {\n *    locale: null || {\n *      ns0: \"lc0\" || [ \"lc0\", ... ],\n *      ns1: \"lc1\" || [ \"lc1\", ... ],\n *      ...\n *    },\n *    global: null || \"module.exports\" || \"exports\" || \"i18n\" || ...\n *  }\n *  ```\n *\n * @memberof MessageFormat\n * @param {string|Object}\n *     messages - The input message(s) to be compiled, in ICU MessageFormat\n * @param {Object} [opt={}] - Options controlling output for non-simple intput\n * @param {Object} [opt.locale] - The locales to use for the messages, with a\n *     structure matching that of `messages`\n * @param {string} [opt.global=\"\"] - The global variable that the output\n *     function should use, or a null string for none. \"exports\" and\n *     \"module.exports\" are recognised as special cases.\n * @returns {function} The first match found for the given locale(s)\n *\n * @example\n * var mf = new MessageFormat('en');\n * var cf = mf.compile('A {TYPE} example.');\n *\n * cf({ TYPE: 'simple' })\n * // 'A simple example.'\n *\n * cf.toString()\n * // 'function (d) { return \"A \" + d.TYPE + \" example.\"; }'\n *\n * @example\n * var fs = require('fs');\n * var mf = new MessageFormat('en');\n * var msgSet = {\n *   a: 'A {TYPE} example.',\n *   b: 'This has {COUNT, plural, one{one member} other{# members}}.'\n * };\n * var cfSet = mf.compile(msgSet, { global: 'module.exports' });\n * var str = cfSet.toString().replace(/^[^{]*{/, '').replace(/}\\s*$/, '').trim();\n * fs.writeFileSync('messages.js', str);\n * ...\n * var messages = require('./messages');\n *\n * messages.a({ TYPE: 'more complex' })\n * // 'A more complex example.'\n *\n * messages.b({ COUNT: 2 })\n * // 'This has 2 members.'\n *\n * @example\n * var mf = new MessageFormat('en');\n * mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;\n * mf.compile({\n *   en: { a: 'A {TYPE} example.',\n *         b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },\n *   fi: { a: '{TYPE} esimerkki.',\n *         b: 'Tämä on {COUNT, selectordinal, other{#.}} esimerkki.' }\n * }, {\n *   locale: { en: 'en', fi: 'fi' },\n *   global: 'i18n'\n * })(this);\n *\n * i18n.en.b({ COUNT: 3 })\n * // 'This is the 3rd example.'\n *\n * i18n.fi.b({ COUNT: 3 })\n * // 'Tämä on 3. esimerkki.'  */\n\n\nMessageFormat.prototype.compile = function (messages, opt) {\n  var r = {},\n      lc0 = this.lc,\n      compileMsg = function (self, msg) {\n    try {\n      var ast = MessageFormat._parse(msg);\n\n      return self._precompile(ast);\n    } catch (e) {\n      throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());\n    }\n  },\n      stringify = function (r, level) {\n    if (!level) level = 0;\n    if (typeof r != 'object') return r;\n    var o = [],\n        indent = '';\n\n    for (var i = 0; i < level; ++i) indent += '  ';\n\n    for (var k in r) o.push('\\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));\n\n    return '{' + o.join(',') + '\\n' + indent + '}';\n  };\n\n  if (typeof messages == 'string') {\n    var f = new Function('number, plural, select, pluralFuncs, fmt', 'return ' + compileMsg(this, messages));\n    return f(this.runtime.number, this.runtime.plural, this.runtime.select, this.runtime.pluralFuncs, this.runtime.fmt);\n  }\n\n  opt = opt || {};\n\n  for (var ns in messages) {\n    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;\n\n    if (typeof messages[ns] == 'string') {\n      try {\n        r[ns] = compileMsg(this, messages[ns]);\n      } catch (e) {\n        e.message = e.message.replace(':', ' with `' + ns + '`:');\n        throw e;\n      }\n    } else {\n      r[ns] = {};\n\n      for (var key in messages[ns]) {\n        try {\n          r[ns][key] = compileMsg(this, messages[ns][key]);\n        } catch (e) {\n          e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:');\n          throw e;\n        }\n      }\n    }\n  }\n\n  this.lc = lc0;\n  var s = this.runtime.toString() + '\\n';\n\n  switch (opt.global || '') {\n    case 'exports':\n      var o = [];\n\n      for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));\n\n      return new Function(s + o.join(';\\n'));\n\n    case 'module.exports':\n      return new Function(s + 'module.exports = ' + stringify(r));\n\n    case '':\n      return new Function(s + 'return ' + stringify(r));\n\n    default:\n      return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));\n  }\n};","map":null,"metadata":{},"sourceType":"script"}